// This file contains sketches of how to encode "planning" into a
// SAT-based solver, for bounded timesteps.
//
// To explain this, I need to cover:
//   1. The core components:
//      (a) the description of the state space; here it is a collection of boolean variables
//      (b) trajectories through the state space; which are derived from:
//      (b) the possible actions that may take place at every step; how are these written?
//      (c) specifications of what we want to see in the state space; e.g. initial and final states; or invariants
//   2. Exercise activities:
//      (a) How to encode a certain state space
//      (b) How to write down properties of states
//      (c) How to write down properties of trajectories:
//          - Initial/final states (i.e. planning)
//          - Invariants (e.g. safety properties)
//          - Step invariants (a state change never happens)
//      (d) How to write down actions from their descriptions

domain timestep { T1, T2, T3, T4 }

// FIXME: this is a literal for all inputs, because equalities are
// always resolved to true/false.
define next(t1 : timestep, t2 : timestep) {
  (t1 != T1 | t2 = T2) &
  (t1 != T2 | t2 = T3) &
  (t1 != T3 | t2 = T4) &
  (t1 != T4)
}

ifsat(true) { for (t1 : timestep) t1 : { for (t2 : timestep) t2 : next(t1,t2) } }

domain action { A1, A2, A3 }
domain variable { A, B, C }

atom isSet(t : timestep, v : variable)

// A way of saying that a variable has the same value in two timesteps
define no_change(v : variable, tNow : timestep, tNext : timestep) {
    (isSet(tNow, v)  | ~isSet(tNext, v))
  & (isSet(tNext, v) | ~isSet(tNow, v))
}

// This is the description of what each of the actions does
//
// Every action has:
//    (a) a precondition: what must the state look like for this action to happen
//    (b) an effect: what does change in the next state
//    (c) a non-effect: what *doesn't* change in the next state (we could automate this)

define effect(act : action, tNow : timestep, tNext : timestep) {
    (act = A1 ==>  // switches 'A', if 'B' is set
       // Precondition
       isSet(tNow, A) & isSet(tNow, B) &
       // Postcondition
       ~isSet(tNext, A) &
       // Frame
       (forall (v : variable) v != A ==> no_change(v, tNow, tNext)))

  & (act = A2 ==> // sets 'B'
       // Precondition
       ~isSet(tNow,B) &
       // Postcondition
       isSet(tNext,B) &
       // Frame
       (forall (v : variable) v != B ==> no_change(v, tNow, tNext)))

  & (act = A3 ==> // unsets 'B'
       // Precondition
       isSet(tNow,B) &
       // Postcondition
       ~isSet(tNext,B) &
       // Frame
       (forall (v : variable) v != B ==> no_change(v, tNow, tNext)))
}

// Generic planning stuff: this works for all planning problems, up to
// the step type

atom active(t : timestep, a : action)

define action_conditions(t : timestep, tNext : timestep) {
  forall (a : action)
    active(t, a) ==> effect(a, t, tNext)
}

define action_choice(t : timestep) {
  // Some action must take place
  (some (a : action) active(t, a))
  &
  // Only one action may take place
  (forall (a1 : action)
    forall (a2 : action)
      a1 = a2 | ~active(t, a1) | ~active(t, a2))
}

// FIXME: should be some nice way of stating this, driven by the type
//
// forall (t : timestep)
//   t != tfinal ==> action_choice(t) & action_conditions(t, t+1)
define steps {
  forall (t1 : timestep)
    forall (t2 : timestep)
      next(t1, t2) ==> action_choice(t1) & action_conditions(t1, t2)
  //   action_choice(T1) & action_conditions(T1, T2)
  // & action_choice(T2) & action_conditions(T2, T3)
  // & action_choice(T3) & action_conditions(T3, T4)
  // & action_choice(T4) & action_conditions(T4, T5)
}

// We can now define some specifications

define initial {
  isSet(T1, A) & ~isSet(T1,B) & ~isSet(T1,C)
}

define final {
  ~isSet(T4,A) // & ~isSet(T4,B)
}

define preservesC {
  (isSet(T1,C) & isSet(T4,C))
}

// Exercise ideas:
// 1. Encode a domain into boolean flags
// 2. Encode a certain set of actions into an 'effect' definition
// 3. Do some planning with given initial and final states, and fixed number of steps
// 4. Encode some invariants that ought to hold all the way through; are there sequences that do this?
// 5. Encode some bad states; are there sequences of steps that can lead to such bad states? (e.g. both trains in the same track location...)

// Point is that we can encode 'action's by how they change the state


// FIXME: need a 'once'; and also should include the state at every timestep.
ifsat (steps & initial & final)
  [ for (t : timestep)
        {
          "state"  : {for (v : variable) v : isSet(t,v)},
          "action" : [if (t != T4) for (a : action) if (active(t,a)) a] // "the (a : action) active(t,a)"
        }
  ]
